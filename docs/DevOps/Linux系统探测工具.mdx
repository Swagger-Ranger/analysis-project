---
title: Linux系统探测工具
sidebar_position: 2
toc_min_heading_level: 2
toc_max_heading_level: 5
---

在工作中，常常需要去巡检服务和定位问题、或者优化性能瓶颈，此时就需要在服务器上面去排查问题。这里针对服务运行在Linux环境下，展示Linux的系统排查工具，特别是对排查服务性能是非常好的工具。



### 系统探测工具

[//]: # (<img src="/Users/liufei/docs/typora笔记/images/devops/linux-0.png" alt="image" style="zoom:36%;" />)
<div style={{ textAlign: 'center', width: '100%' }}>
    <img src="/analysis-project/img/devops/linux-0.png" alt="image" style={{ maxWidth: '72%', height: 'auto', display: 'block', margin: '0 auto' }} />
</div>

如上图Linux系统工具有非常多，这里就写几个常用的，我感觉这几个在日常工作中频率高而且基本够用。

#### uptime

`uptime` 是一个简单的命令行工具，常用于查看系统运行时间、当前时间、系统登录的用户数量以及系统负载情况。它通常作为系统监控和性能分析的一部分，提供了快速了解系统运行状态的手段。

```sh
$ uptime
 14:32:12 up 10 days,  4:45,  3 users,  load average: 0.15, 0.10, 0.08
```

结果解析

1. **`14:32:12`**：输出的第一部分是当前系统的时间。

2. **`up 10 days, 4:45`**：系统运行时间，`10 days` 表示系统已经连续运行了 10 天，`4:45` 表示从最后一次重启到现在的时间是 4 小时 45 分钟。

3. **`3 users`**：当前登录到系统的用户数量，有 3 个用户正在使用这个系统。

4. **`load average: 0.15, 0.10, 0.08`**：系统负载平均值： 1 分钟、5 分钟和 15 分钟的平均负载。系统负载反映的是系统忙碌程度，**通常为正在处理和等待处理的进程数。如果数字接近或超过 CPU 核心的数量（如单核的负载超过 1，双核的负载超过 2），则可能表示系统资源紧张**。

> 负载平均值:系统中可运行的任务数量的平均值。它是一个衡量系统压力的指标，负载值为 1 表示系统的所有资源正好被完全利用。如果该值为 0.5，则表示系统只有一半的资源在使用；而如果该值超过 1.0，则意味着系统有更多的任务在等待资源。



#### top

`top` 是一个实时动态查看系统进程的命令行工具，展示的是当前系统的快照，可以显示系统中正在运行的进程、内存使用情况、CPU使用情况等信息。

```sh
top - 15:32:14 up  2:15,  2 users,  load average: 0.00, 0.01, 0.05
Tasks: 123 total,   1 running, 122 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.3 us,  0.2 sy,  0.0 ni, 99.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  2048040 total,  1028036 free,   473324 used,   548680 buff/cache
KiB Swap:  2097148 total,  2097148 free,        0 used.  1412932 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
 2321 user1     20   0 1440016  62512  46192 S   0.3  3.1   0:01.00 gnome-shell
 1004 user1     20   0  659704  21388  17152 S   0.2  1.0   0:00.20 Xorg
```

命令的输出是分成了两部分：系统当前状态信息、和实时的进程信息

> 进程列表通常是按 **CPU 使用率** (`%CPU`) 进行排序的，使用 CPU 最多的进程会出现在列表的顶部。这个默认设置使用户能够快速识别系统中哪些进程正在占用最多的 CPU 资源。
>
> 因为命令是实时交互式的，所以可以：
>
> **排序**：
>
> - 按 `M` 键：会按 **内存使用率** (`%MEM`) 进行排序，使用最多内存的进程会出现在顶部。
> - 按 `P` 键：按 **CPU 使用率** (`%CPU`) 进行排序，这通常是默认的排序方式。
> - 按 `T` 键：按 **运行时间** (`TIME+`) 进行排序，运行时间最长的进程会在顶部。
> - 按 `N` 键：按 **进程 ID** (`PID`) 进行排序。
>
> **终止进程**：按 `k` 键，然后输入要终止的进程 ID (PID)。
>
> **显示进程树**：按 `V` 键，可以看到进程树。
>
> **过滤进程**：按 `o` 键可以对显示的进程进行过滤，例如 `COMMAND=java` 只显示 Java 进程。
>
> **退出**：按 `q` 键退出 `top` 命令界面。

**系统当前状态信息**

1. `top - 15:32:14 up  2:15,  2 users,  load average: 0.00, 0.01, 0.05`，这样行是系统概要信息，和`uptime`的输出含义是一样的。

2. `Tasks: 123 total,   1 running, 122 sleeping,   0 stopped,   0 zombie`，显示系统中的任务/进程的总数，以及正在运行、睡眠、停止、僵尸状态的进程数量。

3. `%Cpu(s):  0.3 us,  0.2 sy,  0.0 ni, 99.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st`，cpu使用率

`us`：用户态 CPU 时间百分比（用户进程消耗的 CPU 时间）。

`sy`：系统态 CPU 时间百分比（内核进程消耗的 CPU 时间）。

`ni`：用户进程通过 nice 调整优先级后的 CPU 时间百分比。

`id`：空闲 CPU 时间百分比。

`wa`：等待 I/O 操作的 CPU 时间百分比。

`hi`：硬件中断消耗的 CPU 时间百分比。

`si`：软件中断消耗的 CPU 时间百分比。

`st`：虚拟机偷取的 CPU 时间百分比。

4. `KiB Mem :  2048040 total,  1028036 free,   473324 used,   548680 buff/cache`，物理内存的使用情况，包括总量、已使用、空闲、缓冲区和缓存。

5. `KiB Swap:  2097148 total,  2097148 free,        0 used.  1412932 avail Mem`，交换分区的使用情况，包括总量、已使用、空闲以及交换缓存。



**实时进程信息**

- PID：进程 ID。

- USER：进程所有者的用户名。

- PR：进程的优先级。 -- *`PR` = 20 + `NI`，`PR` 值越小，调度优先级越高，操作系统会更频繁地调度这个进程获得的cpu时间就越多，越小获得的cpu时间就越少，一般是20，就是NI一般为0，加20就是PR值*

- NI：进程的 nice 值（影响优先级）。-- *范围 `-20到19`，Nice 值越小优先级越高，-20就是最高优先级，一般是0*

- VIRT：进程使用的虚拟内存总量。

- RES：进程使用的物理内存量（驻留内存）。

- SHR：进程使用的共享内存量。

- S：进程的状态（R：运行，S：睡眠，D：不可中断的睡眠，Z：僵尸进程，T：停止）。

- %CPU：进程使用的 CPU 时间百分比。

- %MEM：进程使用的内存百分比。

- TIME+：进程使用的 CPU 时间总和。

- COMMAND：进程启动的命令或路径。



#### vmstat

`vmstat`是个丰富而强大的系统工具

语法：`vmstat [-V] [-n] [delay [count]]`

-V：显示vmstat版本信息。
-n：只在开始时显示一次各字段名称。
-a：显示活跃和非活跃内存
-d：显示磁盘相关统计信息。
-p：显示指定磁盘分区统计信息。
-s：显示内存相关统计信息及多种系统活动数量。
-m：显示slabinfo
-S：使用指定单位显示。参数有 k 、K 、m 、M ，分别代表1000、1024、1000000、1048576字节（byte）。默认单位为K（1024 bytes）
-f：显示从系统启动至今的fork数量 。

delay：刷新时间间隔。
count：刷新次数。如果不指定刷新次数，但指定了刷新时间间隔，这时刷新次数为无穷。



```tex
[root@liufei ~]# vmstat 2
procs -----------memory---------------- ---swap-- -----io---- --system-- -----cpu-----
 r  b      swpd  free   buff   cache      si   so    bi    bo   in cs   us sy id wa st
 0  0      0 233481328 758304 20795516    0    0     0     1    0    0  0  0 100  0  0
 0  0      0 233480800 758304 20795520    0    0     0     0  951 1519  0  0 100  0  0
 0  0      0 233481056 758304 20795520    0    0     0     0  867 1460  0  0 100  0  0
 0  0      0 233481408 758304 20795520    0    0     0    20  910 1520  0  0 100  0  0
 0  0      0 233481680 758304 20795520    0    0     0     0  911 1491  0  0 100  0  0
 0  0      0 233481920 758304 20795520    0    0     0     0  889 1530  0  0 100  0  0
```

*需要着重注意的指标，我加粗了*

procs（进程信息）:

- **r**: 表示运行队列数即等待运行的进程数，即当前等待 CPU 处理的进程数。
- **b**: 表示阻塞的进程即正在等待资源（例如 I/O 操作）的进程数。

memory（内存信息）:

- swpd: 已使用的交换空间即虚拟内存的大小（以 KB 为单位）。--[虚拟内存](#虚拟内存)
- free: 空闲内存的大小（以 KB 为单位）。
- buff: 用作缓冲区的内存大小（以 KB 为单位）--*临时存储写入到磁盘的数据。这是一块内存区域，用来存放即将写入磁盘的数据，以减少直接的磁盘写操作。这样，操作系统可以将多个写入操作合并为一次，以提高磁盘的写入效率*。
- cache: 用作缓存的内存大小（以 KB 为单位）--*存储从磁盘中读取的数据。操作系统使用缓存来存储最近访问过的数据块，以便在下次访问这些数据时可以直接从内存中获取，而不必再次访问磁盘，从而加快数据读取速度。*

swap（交换区信息）: --*swap中的数值很大，说明内存不够，在频繁发生内存交换，而这会影响性能*

- **si**: 从磁盘中交换到内存的数量（以 KB 为单位）--*每秒钟发生的交换量*。
- **so**: 从内存交换到磁盘的数量（以 KB 为单位）。

io（磁盘 I/O 信息）:

- bi: 块设备的输入块数量（以块为单位）--*每秒钟的数据量*。
- bo: 块设备的输出块数量（以块为单位）。

system（系统信息）:

- in: 每秒中断的数量，包括时钟中断。--[中断](#中断)
- **cs**: 每秒上下文切换的数量。-- *每秒上下文切换次数，比如系统调用，线程的切换。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用。*

cpu（CPU 信息）:

- **us**: 用户进程（非内核进程）消耗的 CPU 时间百分比。-- *在虚拟化的环境中，这个指标可能会不准，会超过100%*
- **sy**: 内核进程消耗的 CPU 时间百分比。-- *如果太高，表示系统调用时间长，例如是IO操作频繁。*
- id: CPU 空闲时间百分比。-- *一般来说，`id + us + sy = 100`。*
- **wa**: 等待 I/O 操作完成的时间百分比。 --*如果很高，就说明io性能瓶颈，导致了cpu处于io等待中*
- st: 被虚拟机偷取的 CPU 时间百分比 --[CPU时间偷取](#CPU时间偷取)

可以看到上面的指标都是作了分类，将影响性能的维度分类就有下面4个：

- CPU（cpu性能很大一部分决定了系统整体的性能）
- procs.r持续有值，且大于系统CPU数量，则认为系统不足以支撑当前的负载（因为一直有进程在等待运行），可能是软件实现问题或者需要升级硬件系统
- cpu.id(cpu idle时间)持续为0,表示CPU持续忙，需要根据cpu.sy,cpu.us继续查找原因
- cpu.sy,cpu.us持续高，且cpu.sy大于cpu.us表示系统频繁在内核态执行，可能存在频繁的或较多的系统调用或者IO访问
- 内存（物理内存不够时会使用交换内存，使用swap会带来磁盘io和cpu的开销）
- memory.swpd数值持续有值，说明系统内存不足且使用了虚拟内存，需要加大内存。
- IO-硬盘（存储系统）
- 小文件读写瓶颈是磁盘的寻址（tps），大文件读写的性能瓶颈是带宽
- Linux可以利用空闲内存作文件系统访问的cache，因此系统内存越大存储系统的性能也越好

- IO-网络带宽



#### iostat

`iostat` 是一个属于 `sysstat` 包下的监控IO和CPU使用情况的工具，它提供了一个持续的磁盘活动视图。

语法：`iostat [options] [interval] [count]`

- `options`：扩展参数，比如：-x就是扩展统计信息

- `interval`：指定输出更新的时间间隔（以秒为单位）。

- `count`：指定输出的次数。

```sh
root@fc2a648b9c4c:/# iostat 1
Linux 5.10.104-linuxkit (fc2a648b9c4c) 	06/20/24 	_aarch64_	(4 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.10    0.00    0.09    0.01    0.00   99.79

Device             tps    kB_read/s    kB_wrtn/s    kB_dscd/s    kB_read    kB_wrtn    kB_dscd
vda               1.81        19.82       110.17      2770.58     418435    2326260   58502892
```

*加粗的就是需要关注的指标*

**CPU 使用情况**

这些字段显示CPU的使用情况，以百分比表示。

- `%user`：CPU在用户空间的使用百分比（不包括内核空间）。
- `%system`：CPU在内核空间的使用百分比。
- **`%iowait`**：CPU在等待I/O操作完成的时间百分比。
- `%idle`：CPU处于空闲状态的时间百分比。
- `%steal`：虚拟化环境中，被虚拟机监控程序窃取的CPU时间百分比（在虚拟机中使用时）。

**设备I/O**

这些字段显示各个存储设备的I/O统计数据。

- `Device`：设备名称。 --*这个是按磁盘区分了的，可以看到每块磁盘各自的数据*
- **`tps`**：每秒传输的I/O请求次数（transfers per second），即每秒的磁盘事务数。
- **`kB_read/s`**：每秒读取的数据量（以KB为单位）。
- **`kB_wrtn/s`**：每秒写入的数据量（以KB为单位）。
- `kB_read`：自系统启动以来读取的总数据量（以KB为单位）。
- `kB_wrtn`：自系统启动以来写入的总数据量（以KB为单位）。



#### netstat

`netstat` 是一个网络统计工具，用于显示网络连接、路由表、接口统计、伪网络设备和网络协议的统计信息。工具在`net-tools`包下面，安装的命令是`apt install net-tools`。

语法：`netstat [options]`

Options:

`-a` 或 `--all`：显示所有的网络连接和监听的端口。

`-t` 或 `--tcp`：显示TCP连接。

`-u` 或 `--udp`：显示UDP连接。

`-l` 或 `--listening`：仅显示正在监听的端口。

`-p` 或 `--program`：显示使用每个连接的程序的进程ID（PID）和名称。

`-n` 或 `--numeric`：以数字形式显示地址和端口号，避免主机名和服务名解析。

`-r` 或 `--route`：显示路由表。

`-i` 或 `--interfaces`：显示网络接口列表及其统计信息。

`-s` 或 `--statistics`：显示网络协议的统计信息。

`-e` 或 `--extend`：显示额外的网络接口统计信息。



```sh
#netstat -a
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN
tcp6       0      0 :::80                   :::*                    LISTEN
```

输出的是系统中的开放端口和活跃服务。

> `Proto`：协议类型（TCP或UDP）。
>
> `Recv-Q`：接收队列中的字节数（待处理数据）。
>
> `Send-Q`：发送队列中的字节数（等待确认数据）。
>
> `Local Address`：本地地址和端口。
>
> `Foreign Address`：远程地址和端口。
>
> `State`（仅TCP连接）：连接的当前状态（如 `ESTABLISHED`、`LISTENING`、`CLOSE_WAIT` 等）。



```sh
netstat -an | grep -c ':80'
```

- `-a`: 显示所有连接和监听端口。
- `-n`: 以数字形式显示地址和端口号，而不是尝试解析为主机名和服务名称。

- `grep -c`: 计算匹配的行数。

输出的是特定端口的链接数，这个特别有用，因为可以快速知道特定服务的负载。

> netstat 还有其他参数和返回数据含义，这里没有写。。。



#### sar

`sar`（System Activity Reporter）也是属于 `sysstat` 工具集的一个强大的系统性能监控和报告工具，`sar` 可以提供有关 CPU 负载、内存使用、I/O 活动、网络流量等的详细报告，虽然这些指标其他命令也能提供，但sar有个特别的地方在于其可以保存历史数据，这使得其能使用在需要长期监控和日志分析的场景中。



**查看cpu**

`sar -u 1 5`  查看cpu，每隔 1 秒记录一次，持续 5 次

```sh
root@fc2a648b9c4c:/# sar -u 1 5
Linux 5.10.104-linuxkit (fc2a648b9c4c) 	06/20/24 	_aarch64_	(4 CPU)

17:47:18        CPU     %user     %nice   %system   %iowait    %steal     %idle
17:47:19        all      0.00      0.00      0.25      0.00      0.00     99.75
17:47:20        all      0.00      0.00      0.25      0.00      0.00     99.75
17:47:21        all      0.00      0.00      0.00      0.00      0.00    100.00
17:47:22        all      0.00      0.00      0.00      0.00      0.00    100.00
17:47:23        all      0.50      0.00      0.25      0.00      0.00     99.25
Average:        all      0.10      0.00      0.15      0.00      0.00     99.75
```

**查看内存**

```sh
root@fc2a648b9c4c:/# sar -r 1 5
Linux 5.10.104-linuxkit (fc2a648b9c4c) 	06/20/24 	_aarch64_	(4 CPU)

17:47:30    kbmemfree   kbavail kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty
17:47:31      4945136   6876480    595464      7.41     74416   2255132   3447340     37.93    442952   2412448         8
17:47:32      4945136   6876480    595456      7.41     74416   2255132   3447340     37.93    442952   2412448         8
17:47:33      4945168   6876512    595424      7.41     74416   2255132   3447340     37.93    442952   2412448         8
17:47:34      4945168   6876512    595424      7.41     74416   2255132   3447340     37.93    442952   2412448         8
17:47:35      4945168   6876512    595424      7.41     74416   2255132   3447340     37.93    442952   2412448         8
Average:      4945155   6876499    595438      7.41     74416   2255132   3447340     37.93    442952   2412448         8
```

- `kbmemfree`：系统当前未使用的空闲内存量，单位是 KB (Kilobytes)。反映系统可用的物理内存。如果值较大，表示系统有较多的可用内存。

- `kbavail`： 近似估算系统中实际可用的内存（包括缓存和缓冲区的可释放内存），单位是 KB。这是用户可用的内存量，通常比 `kbmemfree` 更能反映系统的实际内存情况，因为它考虑了可释放的缓存和缓冲。

- `kbmemused`：系统已使用的内存量，单位是 KB。反映系统目前正在使用的物理内存。

- **`%memused`**：系统已使用的内存百分比。计算公式: `%memused = (kbmemused / (kbmemused + kbmemfree)) * 100`。这是一个总体的内存使用率指标，表示系统的内存负载。

- `kbbuffers`：用于缓冲区缓存的内存量，单位是 KB。缓冲区缓存用于临时存储文件系统操作的数据（例如，读写操作的元数据）。较高的缓冲区内存表明系统频繁地与存储设备进行交互。

- **`kbcached`**：用于页缓存的内存量，单位是 KB。页缓存用于缓存磁盘上的数据文件，较高的缓存量表明系统可能在重用之前读取过的数据，从而减少对磁盘的访问。

- `kbcommit`：提交到虚拟内存中的内存量，单位是 KB。这表示系统中所有任务当前提交的虚拟内存总量，可能包括交换分区中的内存。

- **`%commit`**：提交的虚拟内存占系统总内存的百分比。该值越高，表示系统分配的虚拟内存越多，可能需要依赖交换分区（swap）来满足内存需求。

- `kbactive`：目前在使用中的内存量，单位是 KB。反映活跃使用的内存量，通常是操作系统核心和运行的进程正在使用的内存。

- `kbinact`：当前不活跃的内存量，单位是 KB。这些内存区域中存储的内容可能不再频繁使用，但仍然保留在内存中，以备将来可能的访问。

- **`kbdirty`**： 需要写回到磁盘的数据量，单位是 KB。 这部分内存包含已修改但尚未同步回磁盘的数据。较高的数值可能意味着系统有较多的数据需要写入磁盘。



**查看cpu队列数**

[cpu队列](#cpu队列)，是cpu调度机制的一部分，反映了系统在特定时刻有多少进程在等待 CPU 资源。

```sh
root@fc2a648b9c4c:/# sar -q 1 5
Linux 5.10.104-linuxkit (fc2a648b9c4c) 	06/20/24 	_aarch64_	(4 CPU)

18:46:27      runq-sz  plist-sz   ldavg-1   ldavg-5  ldavg-15   blocked
18:46:28            0       549      0.02      0.03      0.00         0
18:46:29            0       550      0.02      0.03      0.00         0
18:46:30            1       550      0.02      0.03      0.00         0
18:46:31            0       550      0.02      0.03      0.00         0
18:46:32            0       550      0.02      0.03      0.00         0
Average:            0       550      0.02      0.03      0.00         0
```

- `runq-sz` (运行队列大小)：当前运行队列中的进程数量。运行队列是指那些已经准备好运行，但由于 CPU 忙碌而在等待执行的进程。队列长度越大，通常表明系统的负载越高。

- `plist-sz` (进程列表大小)：当前存在的进程和线程的总数。这个数字包括所有状态的进程，不仅仅是正在运行的进程。比如：在上面输出中，`plist-sz` 稳定在 549 或 550，表示系统中有大约 550 个进程或线程存在。

- `ldavg-1` (1 分钟平均负载)：表示系统在过去 1 分钟的平均负载。平均负载不仅包括正在运行的进程，还包括等待运行的进程。比如：在上面输出中，`ldavg-1` 大约为 0.02，表明系统在最近 1 分钟的负载非常低。

- `ldavg-5` (5 分钟平均负载)

- `ldavg-15` (15 分钟平均负载)

- `blocked` (被阻塞的进程数量)：正在等待 I/O 操作完成的进程数。如果这个数字较大，可能表示 I/O 子系统存在瓶颈。比如在上面输出中，`blocked` 始终为 0，表明没有进程被 I/O 操作阻塞。





**查看IO**

```sh
root@fc2a648b9c4c:/# sar -b 1 5
Linux 5.10.104-linuxkit (fc2a648b9c4c) 	06/20/24 	_aarch64_	(4 CPU)

17:48:05          tps      rtps      wtps      dtps   bread/s   bwrtn/s   bdscd/s
17:48:06         0.00      0.00      0.00      0.00      0.00      0.00      0.00
17:48:07         0.00      0.00      0.00      0.00      0.00      0.00      0.00
17:48:08         0.00      0.00      0.00      0.00      0.00      0.00      0.00
17:48:09         0.00      0.00      0.00      0.00      0.00      0.00      0.00
17:48:10         0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:         0.00      0.00      0.00      0.00      0.00      0.00      0.00
```

- `tps` (Transfers per Second)：每秒发生的 I/O 传输次数。每次 I/O 传输对应一次数据块的读或写操作。如果 `tps` 较高，表示系统在短时间内处理了大量的读写操作，可能是高负载的信号。

- `rtps` (Read Transfers per Second)： 每秒发生的读操作传输次数。 反映了系统从磁盘读取数据的频率。如果 `rtps` 较高，表示系统正在频繁地读取数据。

- `wtps` (Write Transfers per Second)：每秒发生的写操作传输次数。反映了系统向磁盘写入数据的频率。如果 `wtps` 较高，表示系统正在频繁地写入数据。

- `dtps` (Discard Transfers per Second)：每秒丢弃的传输次数（即 TRIM 操作），通常与 SSD 设备相关，用于释放不再使用的块。显示了系统对 SSD 设备进行的 TRIM 操作的频率，通常在磁盘被大规模删除或清理时有所增加。

- `bread/s` (Blocks Read per Second)：每秒从设备读取的数据块数。显示了系统读取数据的总量，如果该值较高，表示系统正在大量读取数据。

- `bwrtn/s` (Blocks Written per Second)：每秒向设备写入的数据块数。显示了系统写入数据的总量，如果该值较高，表示系统正在大量写入数据。

- `bdscd/s` (Blocks Discarded per Second)：每秒丢弃的数据块数（与 `dtps` 对应）。反映了系统对块设备的 TRIM 操作频率，这通常在 SSD 设备上出现，用于优化存储性能。



**查看网络接口**

> 新建的机器，没有实际的运行数据

```sh
root@fc2a648b9c4c:/# sar -n DEV 1 5
Linux 5.10.104-linuxkit (fc2a648b9c4c) 	06/20/24 	_aarch64_	(4 CPU)

17:48:37        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
17:48:38           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
17:48:38        tunl0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
17:48:38      ip6tnl0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
17:48:38         eth0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00

...

Average:        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
Average:           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:        tunl0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:      ip6tnl0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
Average:         eth0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
```

`lo`、`tunl0`、`ip6tnl0` 、`eth0` 对应的就是[网络接口](#网络接口)。

- `IFACE` (Interface)：网络接口的名称，如 `lo`（回环接口）、`eth0`（以太网接口）

- `rxpck/s` (Received Packets per Second)：每秒接收到的数据包数量。反映了该接口每秒钟接收的数据包的频率。如果值较高，表示网络流量较大。

- `txpck/s` (Transmitted Packets per Second)：每秒发送的数据包数量。反映了该接口每秒钟发送的数据包的频率。如果值较高，表示网络流量较大。

- `rxkB/s` (Received Kilobytes per Second)：每秒接收到的字节数（以千字节为单位）。表示每秒接收到的数据量，反映了该接口的输入带宽使用情况。

- `txkB/s` (Transmitted Kilobytes per Second)：每秒发送的字节数（以千字节为单位）。表示每秒发送的数据量，反映了该接口的输出带宽使用情况。

- `rxcmp/s` (Compressed Packets Received per Second)：每秒接收到的压缩数据包的数量。通常用于支持压缩的网络接口，这个值显示压缩接收流量的频率。

- `txcmp/s` (Compressed Packets Transmitted per Second)：每秒发送的压缩数据包的数量。通常用于支持压缩的网络接口，这个值显示压缩发送流量的频率。

- `rxmcst/s` (Multicast Packets Received per Second)：每秒接收到的组播数据包的数量。显示通过该接口接收到的组播流量，组播是用于在网络中向多个接收者同时发送数据的一种技术。

- `%ifutil` (Interface Utilization Percentage)：网络接口的使用率，表示该接口相对于其最大带宽的使用百分比。如果该值接近 100%，意味着接口已经接近其最大处理能力，可能需要优化网络配置或扩展带宽。



**sar系统监测**

如果要使用`sar`的历史监测功能，就必须打开`sar` 数据收集服务，其由 `sysstat` 服务管理。这个服务通常默认启动，并定期收集系统性能数据。

```sh
systemctl status sysstat
```

然后查看历史的监测数据才能看到数据

比如：`sar -s 09:00:00 -e 18:00:00`查看指定历史时间

一些`sar`命令参数：

- `-s` 参数指定报告的起始时间。时间格式为 `HH:MM:SS`，

- `-e` 指定数据的结束时间

- `-f` ：从指定的文件中读取历史数据。默认情况下，`sar` 数据文件通常保存在 `/var/log/sa/` 目录中，文件名通常为 `sa<dd>`，其中 `<dd>` 表示日期，比如：`sar -f /var/log/sa/sa18`

- `-i`： 设置采样的间隔时间，单位为秒。`sar -i 5 -s 09:00:00 -e 18:00:00`





### 基础概念

#### 虚拟内存

在系统中运行的每个进程都需要使用到内存，但不是每个进程都需要每时每刻使用系统分配的内存空间。当系统运行所需内存超过实际的物理内存，内核会释放某些进程所占用但未使用的部分或所有物理内存，将这部分资料存储在磁盘上直到进程下一次调用，并将释放出的内存提供给有需要的进程使用。

在Linux内存管理中，主要是通过“调页Paging”和“交换Swapping”来完成上述的内存调度。调页算法是将内存中最近不常使用的页面换到磁盘上，把活动页面保留在内存中供进程使用。交换技术是将整个进程，而不是部分页面，全部交换到磁盘上。

分页(Page)写入磁盘的过程被称作Page-Out，分页(Page)从磁盘重新回到内存的过程被称作Page-In。当内核需要一个分页时，但发现此分页不在物理内存中(因为已经被Page-Out了)，此时就发生了分页错误（Page Fault）。

当系统内核发现可运行内存变少时，就会通过Page-Out来释放一部分物理内存。尽管Page-Out不是经常发生，但是如果Page-out频繁不断的发生，直到当内核管理分页的时间超过运行程式的时间时，系统性能会急剧下降。这时的系统已经运行非常慢或进入暂停状态，这种状态亦被称作thrashing(颠簸)

#### cpu队列

在 Linux 系统中，CPU队列（也称为运行队列`run queue`）是指那些准备好运行但当前没有CPU时间片可以执行的进程。这些进程已经过调度程序的调度，但因为 CPU 正在处理其他任务，它们必须等待一段时间才能获得 CPU 的执行机会。CPU 队列是由内核维护的一个列表，存放所有当前准备好运行但尚未获得 CPU 执行的进程。当系统中的进程发出执行请求时，内核的调度程序会将它们放入这个队列中，并按照一定的调度算法决定何时将某个进程从队列中取出并分配给 CPU。



#### 中断

**中断** 是由硬件或软件生成的信号，用于引起处理器的注意，要求它暂停当前的执行流程，去处理更紧急的任务。中断可以由许多不同的事件触发，例如：

- **硬件中断**：来自硬件设备的信号，比如键盘输入、网络数据包到达、磁盘I/O等。
- **时钟中断**：由系统时钟生成的定时中断，用于实现时间管理、任务调度等。
- **软件中断**：由软件请求或操作系统发出的中断，如系统调用等。



#### CPU时间偷取

当你的操作系统运行在一个虚拟机中时，虚拟机管理程序会管理多个虚拟机的资源分配。有时候，虚拟机管理程序会把本该属于你的虚拟机的CPU时间分配给其他虚拟机来使用，这段时间就称为“steal time”。`st` 的值表示你的虚拟机因为这种资源分配导致的“CPU偷取时间”，用百分比表示。  当 `st` 值较高时，意味着你的虚拟机可能因为被其它虚拟机抢占了CPU时间而变得性能较差。这个情况在共享资源的虚拟化环境中特别明显。



#### 网络接口

上面的命令返回中`lo`、`tunl0`、`ip6tnl0` 、`eth0` 都是网络接口，并不都是物理网卡。每个接口在系统中的作用不同：

- **`lo` (Loopback Interface)**：系统的回环接口，通常称为 "本地主机" 或 "回环地址"。用于自我通信。任何发送到 `lo` 接口的数据包都会被立即返回到本地主机，而不会离开机器。这通常用于测试和应用程序之间的本地通信。

IP地址 通常绑定到 `127.0.0.1`，这是 IPv4 的回环地址。IPv6 的回环地址为 `::1`。

- **`tunl0` (Tunnel Interface)**：隧道接口，通常用于 IP-in-IP 隧道，将一个 IP 数据包封装在另一个 IP 数据包中的技术。允许不同的网络协议通过这个隧道传输数据。比如，在不同的网络之间建立一个安全通道，以便在互联网上传输数据。例如，使用 `IPSec` VPN 或其他隧道协议时，可能会使用这种接口。

- **`ip6tnl0` (IPv6 Tunnel Interface)**： IPv6 的隧道接口，专门用于 IPv6-in-IPv4 的隧道。它用于将 IPv6 数据包封装在 IPv4 数据包中传输。在 IPv4 网络中传输 IPv6 数据包，主要用于 IPv4 和 IPv6 网络的互通。例如，两个仅支持 IPv6 的节点通过 IPv4 网络通信时，可能会使用这种接口。

- **`eth0` (Ethernet Interface 0)**：典型的以太网接口，通常是物理网卡的表示，连接到物理网络（例如，LAN 或互联网）的接口。这是系统连接到外部网络或互联网的主要接口，在大多数计算机或服务器中，`eth0` 是默认的物理网卡接口。

当然还有别的一下常见的网络接口：

- **`wlan0` (Wireless LAN Interface)**：无线网络接口，表示无线网络卡 (Wi-Fi)。
- **`docker0` (Docker Bridge Interface)**：Docker 创建的默认桥接接口。用于连接和管理 Docker 容器之间的网络通信。`docker0` 将容器连接到主机网络，并允许容器之间的通信。
- **`br0` (Bridge Interface)**：个桥接接口，用于将多个网络接口桥接到一起，使它们看起来像一个网络，实现多个物理或虚拟网络接口之间的通信。在虚拟化环境或需要将多个网络接口（如 `eth0`、`wlan0` 等）连接在同一网络中的场景中使用。
- 等等