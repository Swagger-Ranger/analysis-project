---
title: 虚拟线程
sidebar_position: 9
toc_min_heading_level: 2
toc_max_heading_level: 5
---

这篇文章只是零碎的笔记，没有成体系或者连贯的思绪；后面再补充虚拟线程的内容，虚拟线程/结构化并发是Java一个里程碑式的功能，`Project Loom`真的是自从java8之后Java生态画的最大的一张饼了，而这张饼马上就要兑现了。。。



## 虚拟线程引入背景

JDK的虚拟线程是Project Loom引入的一项新特性，旨在简化并发编程，提升并发性能。虚拟线程（也称为纤程或用户线程）由JVM管理，与操作系统的线程分开管理，使得可以创建和管理大量线程，而不受操作系统线程数量的限制。**在JDK21中已作为正式发布的功能。**



jvm中线程是和操作系统的线程一一对应的。操作系统的线程其实也分了用户线程和内核线程，用户线程就是具体执行任务的，但实际到底层的执行还是都通过内核线程来执行的，内核线程也就是cpu宣称的多少核多少线程的线程；而如果用户线程被阻塞，则内核线程就会切换去执行就绪了的用户线程。

> 虚拟线程使JVM原生具备了类似 Vert.x 框架更轻量的非阻塞响应模式。虚拟线程的引入简化了并发编程模型，使得开发者可以使用更熟悉的同步编程风格，同时获得与异步非阻塞编程相当的性能和资源利用率。
>
> 但虚拟线程比响应式编程更容易追踪和调试调用链路，避免响应式编程的回调地狱*(回调函数时所遇到的复杂性和难度。特别是异步编程中当回调函数嵌套过深时，会导致代码变得难以维护、理解和调试。)*



### jvm线程与操作系统线程

在传统的 JVM 实现中，Java 线程（`java.lang.Thread` 实例）是直接映射到操作系统线程的。这意味着每一个 Java 线程都对应一个操作系统线程，操作系统负责调度这些线程的执行。

**操作系统的线程模型**

现代操作系统通常使用一种混合线程模型，该模型包括用户线程和内核线程：

1. **用户线程**：这些线程在用户空间中创建和管理。它们是由用户级库（例如 Pthreads 库）管理的，用户线程切换通常比内核线程切换更快，因为不涉及操作系统的内核态转换。
2. **内核线程**：这些线程在内核空间中创建和管理，由操作系统内核直接调度。内核线程可以利用多核 CPU 的能力，并且可以在不同的处理器上并行执行。

在许多操作系统中，用户线程最终是由内核线程执行的。具体来说，用户线程被映射到一个或多个内核线程上，由内核线程来实际执行用户线程中的指令。

**用户线程与内核线程的关系**

以下是用户线程与内核线程之间关系的一些常见模式：

1. **一对一模型**（1:1）：每个用户线程对应一个内核线程。这是现代 JVM 的线程模型，如 HotSpot JVM 就采用这种模型。优点是线程的并发性和独立性很好，缺点是创建和管理线程的开销较大。
2. **多对一模型**（M:1）：多个用户线程对应一个内核线程。所有用户线程在一个内核线程上进行调度。优点是线程创建和管理开销较小，缺点是无法利用多处理器的并行能力。
3. **多对多模型**（M:M）：多个用户线程映射到多个内核线程。这种模型结合了一对一和多对一的优点，能够提供高并发性和良好的性能，但实现较为复杂。

**阻塞与调度**

当一个用户线程被阻塞时，以下几种情况可能发生：

1. **在一对一模型中**，阻塞的用户线程会导致对应的内核线程也阻塞。操作系统的调度器会将内核线程从 CPU 上移除，并将 CPU 资源分配给其他可运行的内核线程。
2. **在多对一模型中**，如果一个用户线程阻塞，整个内核线程会被阻塞，所有映射到该内核线程的用户线程都会被阻塞。
3. **在多对多模型中**，一个用户线程的阻塞不会直接导致其他用户线程的阻塞，因为可以将阻塞的用户线程从一个内核线程移到另一个内核线程执行。



虚拟线程因为轻量所以创建成本远小于传统线程（也称为载体线程），并且调度在 JVM 内部完成，不直接映射到操作系统线程，运行在少数的 JVM 传统线程上，**注意：传统线程与操作系统线程之间仍然是一一对应的关系**。



### jvm传统线程模型的局限

受[利特尔定律 (Little's Law)](https://en.wikipedia.org/wiki/Little's_law)支配，该定律将延迟、并发性和吞吐量联系起来：对于给定的请求处理持续时间 (即延迟)，应用程序同时处理的请求数 (即并发性) 必须与到达率 (即吞吐量) 成比例增长。例如，假设平均延迟为 50 毫秒的应用程序通过并发处理 10 个请求实现了每秒 200 个请求的吞吐量。为了使该应用程序扩展到每秒 2000 个请求的吞吐量，它将需要并发处理 100 个请求。如果每个请求在请求持续时间内都在一个线程中处理，那么为了使应用程序跟上，线程数必须随着吞吐量的增长而增长。

然而，可用线程的数量是有限的，因为 JDK 将线程实现为操作系统 (OS) 线程的包装器。OS 线程成本高昂，因此我们不能拥有太多线程，这使得该实现不适合每个请求一个线程的风格。如果每个请求在其持续时间内消耗一个线程，从而消耗一个 OS 线程，那么线程数量通常会在其他资源（如 CPU 或网络连接）耗尽之前成为限制因素。JDK 当前的线程实现将应用程序的吞吐量限制在远低于硬件可以支持的水平。即使线程被池化，也会发生这种情况，因为池化有助于避免启动新线程的高成本，但不会增加线程总数。





## 虚拟线程实现

### park/unpark和continuation

在已有的jvm中，线程是有底层的暂停和唤醒语义的，为什么还有新增continuation来设计虚拟线程暂停和唤醒线程。在已有的juc中的并发操作就是使用的`LockSupport.park()` 和 `LockSupport.unpark()`来协调线程的。

> `LockSupport.park()` 用于暂停线程的执行，直到线程被其他线程唤醒（通过 `LockSupport.unpark()`）、被中断，或者超时。主要用于构建低级同步工具和并发控制机制。
>
> `Continuation` 是一种控制流结构，用于表示和恢复执行点。虚拟线程的调度由 JVM 自己管理，而不是依赖操作系统的调度。

但两者在一些核心方面存在差异：

1. **资源管理**:`LockSupport.park()` 会使线程阻塞，阻塞的线程仍然占用操作系统级资源。这在传统线程中是可接受的，但在虚拟线程中是不经济的，因为虚拟线程的一个目标就是减少对操作系统资源的依赖，支持更大规模的并发。

虚拟线程通过保存和恢复执行上下文来实现暂停和恢复，这使得它们能够在没有阻塞操作系统线程的情况下暂停和恢复执行。

2. **调度机制**:虚拟线程的调度由 JVM 控制，能够更灵活和高效地管理大量虚拟线程。JVM 的调度器可以基于虚拟线程的状态和工作负载来优化线程的执行。

`LockSupport.park()` 依赖于操作系统的线程调度机制，适合用于传统线程模型，但不适合虚拟线程的高并发场景。

3. **非阻塞操作**:虚拟线程设计用于非阻塞操作，而 `LockSupport.park()` 主要用于阻塞操作。非阻塞I/O和其他非阻塞操作是虚拟线程的主要应用场景。

虚拟线程可以在执行阻塞I/O操作时自动挂起自己，并在I/O操作完成后恢复执行，而不需要占用操作系统线程资源。



## 虚拟线程使用注意

### 虚拟线程无法卸载的情况

JDK 中的绝大多数阻塞操作都会卸载虚拟线程，释放其载体和底层操作系统线程以执行新工作。但是，JDK 中的某些阻塞操作不会卸载虚拟线程，因此会阻塞其载体和底层操作系统线程。这是因为操作系统级别（例如，许多文件系统操作）或 JDK 级别（例如[`Object.wait()`](https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/Object.html#wait())）的限制。这些阻塞操作的实现将通过暂时扩展调度程序的并行性来补偿操作系统线程的捕获。因此，调度程序中的平台线程数`ForkJoinPool`可能会暂时超过可用处理器的数量。可以使用系统属性调整调度程序可用的最大平台线程数`jdk.virtualThreadScheduler.maxPoolSize`。

有两种情况会导致虚拟线程在阻塞操作期间无法卸载，因为它被*固定*在其载体上：

1. 当执行`synchronized`块或方法内的代码时，虚拟线程无法被卸载，原因如下：

- **持有监视器锁**：当一个虚拟线程进入一个 `synchronized` 方法或代码块时，它会持有这个对象的监视器锁，持有监视器锁的线程无法被卸载，因为 JVM 需要确保监视器锁的持有和释放的正确性。

- **等待进入 `synchronized` 代码块**：当一个虚拟线程尝试进入一个已经被其他线程持有锁的 `synchronized` 方法或代码块时，它会被阻塞，直到锁被释放。被阻塞等待监视器锁的虚拟线程无法被卸载，因为 JVM 需要维护锁的正确性和线程的等待队列。

- **监视器锁的原子性和一致性**：JVM 需要保证监视器锁的获取和释放操作的原子性和一致性。为了保证这种一致性，持有监视器锁的线程不能被暂停或卸载，否则可能会导致锁的状态不一致。

这个的解决方法如下：

- **ReentrantLock**：ReentrantLock 提供了与 `synchronized` 类似的互斥功能，但它具有更高的灵活性，并且在某些情况下，虚拟线程在等待锁时可以被暂停和卸载。
- **java.util.concurrent 包中的并发工具**：使用 `java.util.concurrent` 包中的工具，如 `Semaphore`、`CountDownLatch`、`CyclicBarrier`、`Exchanger` 等，可以更好地管理并发性和资源利用。
- **非阻塞算法和数据结构**：使用非阻塞算法和数据结构，如 `java.util.concurrent.atomic` 包中的类，可以避免线程阻塞，充分利用虚拟线程的优势。

2. 当它执行一个`native`方法或者一个[外部函数](https://openjdk.java.net/jeps/424)时。

锁定不会使应用程序变得不正确，但可能会影响其可扩展性。如果虚拟线程执行阻塞操作（例如 I/O）或`BlockingQueue.take()`处于锁定状态，则其载体和底层操作系统线程在操作期间会被阻塞。频繁长时间锁定可能会通过捕获载体而损害应用程序的可扩展性。

[//]: # (&nbsp; 加入空格)
&nbsp;


参考资料

[project loom](https://cr.openjdk.org/~rpressler/loom/Loom-Proposal.html)

[jeps-425虚拟线程](https://openjdk.org/jeps/425)

[jeps-428结构化并发](https://openjdk.org/jeps/428)

[jeps-429ScopedValue](https://openjdk.org/jeps/429)

[虚拟线程尝鲜](https://blog.huohaodong.com/blog/project-loom-tasting)

[Java 19 发布，Loom 怎么解决 Java 的并发模型缺陷？](https://www.infoq.cn/article/wg5qybla1ps222larj3y)

[虚拟线程原理及性能分析](https://tech.dewu.com/article?id=89)







