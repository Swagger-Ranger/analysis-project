---
title: Java的值传递和无副作用编程风格
sidebar_position: 5
toc_min_heading_level: 2
toc_max_heading_level: 5
---

Java中的方法调用都是按值传递的，即不管是基本类型还是对象，本质上其参数传入的都是原始对象的副本。我感觉这和无副作用的编程有契合之处*(当然个人一点感受，这两者是不同的概念)*。

说这个其实是在我工作中，遇到很多程序员都爱使用传入对象然后在方法中修改对象的方式来处理业务逻辑，这常常带来很多很麻烦的事情，最让我痛苦的就是，当遇到问题，我必须去排查其写的方法内部逻辑，因为你不知道方法内部对外部的对象做了哪些修改。常常爱传入对象进去，然后在方法内部对对象做修改，这使得对象的修改难以追踪，一个方法中的逻辑还必须去追溯其对象的所有链路，而且常常导致一个对象处处传递，出现在本不应出现的地方。

> 这就是**对象逃逸**和**难以追踪的对象修改**：
>
> - **对象逃逸**：对象的引用从一个作用域（如方法）逃逸到另一个作用域（如返回给调用者）。这种情况可能导致难以追踪的状态问题。
> - **难以追踪的对象修改**：由于副作用，程序中对对象的修改可能会影响到其他地方，导致难以追踪的错误。



### 按值调用与按引用调用

Java 的方法调用语义是纯粹的按值调用(call-by-value)，尽管对于对象引用来说，这意味着被复制的值是对象在堆 中的地址。

- **按值调用**：
- 传递的是参数的值的副本。
- 对参数的任何修改不会影响原始变量或对象。
- Java 中的所有方法调用都是按值传递的，无论是基本数据类型还是对象引用。
- **按引用调用**：
- 传递的是参数的引用，而不是其值。
- 对参数的修改会影响原始对象，因为原始对象和传递的引用指向同一个内存位置。
- 这在 Java 中不适用，因为 Java 仅支持按值传递，虽然对象的引用是按值传递的，但对象的状态可以被修改。



### 按值调用示例

1. **基本数据类型**：

- 对于基本数据类型（如 `int`、`float`、`char` 等），按值传递的拷贝是这些类型的实际值。
- 例如，如果你传递一个 `int` 值到方法中，方法会得到这个 `int` 值的副本，对副本的更改不会影响原始 `int` 变量。

```java
public class Test {
    public static void modifyValue(int x) {
        x = x + 10; // 修改的是 x 的副本
    }

    public static void main(String[] args) {
        int a = 5;
        modifyValue(a);
        System.out.println(a); // 输出 5，a 没有被修改
    }
}
   ```

2. **对象引用**：

- 对于对象（如 `String`、`ArrayList` 等），传递的是对象引用的副本，而不是对象本身。
- 方法可以通过这个引用修改对象的状态，但不能改变原始引用（即对象本身的引用）。

```java
public class Test {
    public static void modifyReference(StringBuilder sb) {
        sb = new StringBuilder("New String"); // 修改的是 sb 的副本，不影响原始引用
        sb.append(" World!");
    }

    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder("Hello");
        modifyReference(sb);
        System.out.println(sb.toString()); // 输出 "Hello"，sb 的内容没有改变
    }
}

   ```

在这个例子中，`StringBuilder` 对象的内容被修改了，但 `sb` 的引用本身没有改变（即 `sb` 仍然指向原来的 `StringBuilder` 对象）。



### 无副作用的编程风格

无副作用的编程风格（也称为**纯函数编程**或**无副作用编程**）被广泛认为是一种良好的编程实践，尤其在需要保证代码可维护性和可预测性时。

1. **参数相同则结果必相同**：无副作用的函数对于相同的输入总是返回相同的输出，增强了代码的可预测性和可测试性。这使得函数行为更容易理解和验证。
2. **方法隔离易于测试**：无副作用的函数只依赖于其输入参数，测试时不需要考虑外部状态的变化，减少了测试的复杂性。
3. **避免状态共享问题而保证线程安全**：由于无副作用的函数不会修改外部状态，它们本质上是线程安全的，这使得并发编程变得更简单。
4. **易于理解、更好的代码维护性**：无副作用的函数逻辑更容易理解，因为函数的行为只依赖于输入参数，而不受外部状态的影响。
5. **易于推理和方法组合**：可以更容易地将纯函数组合成复杂的功能，因为你不需要担心副作用导致的潜在问题。



而无副作用编程风格可很好的避免**对象逃逸**和**难以追踪的对象修改**：

- **对象逃逸**：指的是对象的引用从一个作用域（如方法）逃逸到另一个作用域（如返回给调用者）。这种情况可能导致难以追踪的状态问题。无副作用编程通过使用不可变对象减少了这种风险，因为不可变对象在创建后无法被修改。
- **难以追踪的对象修改**：由于副作用，程序中对对象的修改可能会影响到其他地方，导致难以追踪的错误。无副作用的编程避免了这些问题，因为函数不会修改外部状态。

... todo







