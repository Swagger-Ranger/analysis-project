---
title: data-structure-位图
sidebar_position: 12
toc_min_heading_level: 2
toc_max_heading_level: 5
---

### 位图

位图是一种使用二进制位（0和1）来表示数据的结构，每一位对应一个特定的状态或属性。这种结构通常用于图像处理、内存管理和一些数据压缩算法。

**基本概念**

- 定义：位图是一组二进制位的集合，每个位可以表示一个状态，例如是否存在、是否被访问等。
- 表示方式：通常表示为一个数组或连续的比特流。例如，一个8位的位图可以表示为 `10010110`。

**位图的应用**

- 图像处理：在图像处理中，位图常用于表示黑白图像，每一位表示一个像素的颜色（黑或白）。
- 内存管理：操作系统使用位图来跟踪内存块的分配状态，每个位表示一个内存块是否被占用。
- 布隆过滤器：布隆过滤器使用多个位图来实现快速集合成员查询，尽管可能会产生误报。
- 列式存储中的查询：利用位图索引来加速查询，位图索引为每个不同的列值创建一个位图，查询时可以快速通过位图进行过滤。
- Linux命令中的 `chmod` 命令可以用数字表示文件权限，它的思想与位图也是相同的。



### 位图索引

位图索引是一种高效的数据索引方法，尤其适用于只读或少量更新的数据库，用于快速查询和分析数据。它通过为每个可能的值创建一个位图来加速查询操作。

#### 基本概念

定义：位图索引将每个可能的值映射到一个位图，每个位表示数据集中一个记录的存在与否。

结构：对于一个具有n个可能值的列，会创建n个位图，每个位图的长度与数据集的记录数相同。

**位图索引的优点**

1. 高效查询：位图索引通过使用按位操作（AND、OR、NOT等）来实现快速查询。
2. 压缩存储：位图可以通过压缩技术（如字节填充编码、运行长度编码）来节省存储空间。
3. 适用性：适用于低基数（低基数指的是列中不同值的数量相对较少）和只读或少量更新的数据集。

**位图索引的应用**

- 数据库查询优化：在数据仓库和OLAP（在线分析处理）系统中，位图索引用于加速多维查询和复杂分析。
- 日志分析：在大规模日志数据分析中，位图索引用于快速过滤和聚合操作。
- 基因数据分析：在生物信息学中，位图索引用于基因序列的快速比对和查询。



#### 简单示例

假设我们有一个包含5条记录的表格，每条记录包含一个性别列和一个状态列：

| ID   | 性别 | 状态   |
| ---- | ---- | ------ |
| 1    | M    | 活跃   |
| 2    | F    | 非活跃 |
| 3    | M    | 活跃   |
| 4    | F    | 非活跃 |
| 5    | M    | 活跃   |

为性别列和状态列创建位图索引：

- 性别列位图索引

```less
M: 10101
F: 01010
  ```

- 状态列位图索引

```less
活跃:   10101
非活跃: 01010
  ```

查询示例

- 查询所有男性记录：位图索引：`M` 对应 `10101`
- 查询所有活跃的女性记录：位图索引：`F AND 活跃` 对应 `01010 AND 10101` = `00000`，结果为空，表示没有活跃的女性记录。



#### 位的存储空间

> 位图索引的总位数是记录个数 n 和取值数 k 的乘积。

每个取值的位图：

- 对于每一个取值，我们会有一个位图，每个位图的长度等于记录数 n。
- 因此，每个取值需要 n 位来存储。

总存储空间：

- 如果字段有 k 个不同取值，那么我们将需要 k 个位图，每个位图的长度为 n 位。
- 总存储空间 = k×n 位。



#### 应用示例

下面来看个例子，一个“薪资-年龄”表格如下：

| 年龄 | 薪资 |
| :--- | :--- |
| 25   | 60   |
| 25   | 400  |
| 30   | 260  |
| 45   | 60   |
| 45   | 350  |
| 50   | 75   |
| 50   | 100  |
| 50   | 120  |
| 50   | 275  |
| 60   | 260  |
| 70   | 110  |
| 85   | 140  |

我们为字段年龄建立位图索引：

| 年龄 | 位图         |
| :--- | :----------- |
| 25   | 110000000000 |
| 30   | 001000000000 |
| 45   | 000110000000 |
| 50   | 000001111000 |
| 60   | 000000000100 |
| 70   | 000000000010 |
| 80   | 000000000001 |

现在为薪水字段建立位图索引

| 薪水 | 位图         |
| :--- | :----------- |
| 60   | 100100000000 |
| 400  | 010000000000 |
| 260  | 001000000100 |
| 350  | 000010000000 |
| 75   | 000001000000 |
| 100  | 000000100000 |
| 120  | 000000010000 |
| 275  | 000000001000 |
| 110  | 000000000010 |
| 140  | 000000000001 |

我们以上述为基础，找出年龄在 `45~55`且薪水范围在`100~200`之间记录。首先找到范围内的年龄向量，并对它们进行按位或操作得到一个新的向量：

```less
000110000000
|
000001111000
=
000111111000
```

就得到符合年龄的记录。
然后找到符合薪水的向量，同样对他们进行按位或操作得到一个新向量：

```less
000000100000
|
000000010000
|
000000000010
|
000000000001
=
000000110011
```

现在我们对上面的两个新向量进行按位与来求交集：

```less
000111111000
&
000000110011
=
000000110000
```

也就得出第7个和第8个记录是符合约束条件的。

> 使用位图向量求交集时用按位与，并集用按位或！！！



#### 位图索引的管理

位图索引相关的三个问题：

- 1、 **查找位向量**：当想要查找一个给定值的位向量，或者给定范围内的值对应的多个位向量时，我们如何有效地找到它们；

把位向量看成记录，它们的键是对应于该位向量的字段值。然后任何辅助索引技术都可以使我们有效地按值找到它们的位向量。
我们存储位向量时，把他们当做可变长记录。这是因为随着数据文件中记录的增加，它们一般会增长。

- 2、 **查找记录**：当我们已经选择好回答查询查询的记录集时，我们如何有效地检索记录；

我们可在数据文件上创建辅助索引（稠密索引，无序，桶），它的索引键是记录号。

- 3、 **更新位图索引**：当出现插入或者删除时，如何调整给定字段的位图索引；





### 位图压缩

位图的压缩和解压方法旨在减少存储空间，同时允许快速查询操作。常用的压缩算法有运行长度编码（RLE，Run-Length Encoding）、字节填充编码（BBC，Byte-aligned Bitmap Code,）、字节填充二进制编码（WBC，Word-Aligned Binary Code）和基于词的压缩（Word-Aligned Hybrid, WAH）等。

> 本质上，计算机中的所有数据都是以二进制形式存储和处理的，因此数据压缩技术理论上对所有类型的数据都是适用的。数据压缩的主要目标是减少数据的冗余，从而减少存储空间或传输时间。解压缩过程则是将压缩的数据还原为其原始形式。
>
> **无损压缩**：原始数据可以完全恢复，没有任何信息损失
>
> - 运行长度编码（Run-Length Encoding, RLE）：压缩连续重复的元素。
>
> - 哈夫曼编码（Huffman Coding）：根据数据出现的频率生成前缀码，频率高的数据使用较短的编码。
>
> - 算术编码（Arithmetic Coding）：将整个消息编码为一个数值区间，频率高的符号对应较短的区间。
>
> - Lempel-Ziv-Welch（LZW）：通过构建字典来压缩数据流，常用于GIF和PNG格式。
>
> **有损压缩**：允许一定的信息丢失，通常用于多媒体文件（图像、音频、视频）。
>
> - JPEG：对图像进行有损压缩，通过离散余弦变换（DCT）去除人眼不敏感的信息。
> - MP3：对音频进行有损压缩，通过心理声学模型去除人耳不敏感的声音。



#### 运行长度编码

将位图按照连续的0和连续的1的数量进行分段，然后用数字表示这些分段，以(连续0的长度,连续1的长度)为格式存储。解码也按此格式解码。分段长度编码步骤：

1. **扫描位图**：从头到尾扫描位图，识别连续0和1的段。
2. **记录长度**：记录每段连续0和1的长度，并成对存储。



比如：`10001111100111100`，扫描位图为：

`1` -> 0个0, 1个1

`000` -> 3个0

`11111` -> 5个1

`00` -> 2个0

`1111` -> 4个1

`00` -> 2个0

依次记录每段连续0和1的长度，并成对存储：

- 第1段：0个0, 1个1 -> `(0, 1)`
- 第2段：3个0 -> `(3)`
- 第3段：5个1 -> `(5)`
- 第4段：2个0 -> `(2)`
- 第5段：4个1 -> `(4)`
- 第6段：2个0 -> `(2)`

编码：对每个分段内的连续0和1进行编码，记录每段连续0和1的长度：

- 分段1：`00001111` -> `4,4` （4个连续0，4个连续1）
- 分段2：`00000000` -> `8,0` （8个连续0，0个连续1）
- 分段3：`11111111` -> `0,8` （0个连续0，8个连续1）
- 分段4：`0000` -> `4,0` （4个连续0，0个连续1）

合并成一个列表，依次记录：

- `0, 1, 3, 5, 2, 4, 2`

解码过程就是反过来。

**优点**

1. 高效压缩：对于稀疏位图，可以显著减少存储空间，因为它有效地利用了连续0或1的长度信息。
2. 快速解码：解码过程相对简单，只需读取编码对并生成相应的位图段。

**缺点**

1. 适用性有限：对于不太稀疏的位图，分段长度编码的压缩效果可能不如其他压缩方法。

> 比如：上面的例子`10001111100111100`压缩出来二进制是`0、1、11、101、10、100、10`，算上分隔符，效率就太低了

2. 复杂性增加：在某些情况下，处理和维护多个连续段的编码结果可能会增加复杂性。

**可以估算其压缩率，就是比如 `00000000`这些位数是2的n次方表示数字，变成了其长度的n；也就是一个将一个数字N的二进制长度空间变成了log2N + m的二进制长度空间，m就是增加的额外格式的空间。压缩率大约就是：(log2N + m)/N。**



#### 字节填充编码BBC

字节填充编码就是将字节进行拆分，增加前缀，当都是0或者都是1时，就通过前缀来识别不存储实际的字符，而当存在有0又有1时才存储实际的字符。

**压缩过程**

1. **初始化**：将位图数据按字节读取，并初始化压缩数据的存储结构。
2. **分块处理**：将位图数据划分为若干字节块，每个块包含8位（1字节），**字节块的长度是固定的，长度通常都是8位1字节，如果有很多长度相同的可以增加分割的长度这样能用更少的字符来表示，但增加分块的长度也增加了有1又有0的概率**。
3. **编码块**：
- 对每个字节块进行编码：
- 如果字节块全为0或全为1，则将其编码为特殊的控制字节，以表示这些字节块是全0或全1。
- 如果字节块中有混合的0和1，则将其直接作为数据字节存储，并添加一个前缀字节来指示这是一个数据字节。
- 使用前缀字节来指示数据块的类型：
- `0x00` 表示后续字节块全为0。
- `0xFF` 表示后续字节块全为1。
- 其他值则表示后续的字节是一个数据字节，需要直接存储。
4. **压缩结果**：将处理过的字节块序列组合在一起，形成最终的压缩数据。

**解压缩过程**

1. **初始化**：将压缩数据按字节读取，并初始化解压缩数据的存储结构。
2. **分块解码**：按顺序读取压缩数据的每个字节块，根据前缀字节来判断如何解码：
- 如果前缀字节是 `0x00`，则将对应的字节块解码为全0的字节块。
- 如果前缀字节是 `0xFF`，则将对应的字节块解码为全1的字节块。
- 如果前缀字节是其他值，则将其作为数据字节块直接存储到解压缩结果中。
3. **解压缩结果**：将解码后的字节块序列组合在一起，形成最终的解压缩数据。



**示例：**

一个简单的位图数据：

```less
11001100 11001100 00000000 11111111 11001100 11001100
```

压缩过程如下：

1. 将数据划分为字节块：

```less
11001100
11001100
00000000
11111111
11001100
11001100
   ```

2. 编码每个字节块：

- `11001100` 不全是0或1，作为数据字节存储，并添加前缀字节 `0x01`。
- `11001100` 同上。
- `00000000` 全是0，使用前缀字节 `0x00` 表示。
- `11111111` 全是1，使用前缀字节 `0xFF` 表示。
- `11001100` 同上。
- `11001100` 同上。

3. 压缩结果：

```less
0x01 11001100
0x01 11001100
0x00
0xFF
0x01 11001100
0x01 11001100
   ```

解压缩就是反过来。



#### 字对齐二进制压缩（WBC）

和BBC的压缩方式是一样的，两者的差别就是BBC按字节（8位）进行分块，WBC按字（通常是32位或64位）进行分块。



#### 基于词的压缩WAH

就是将位图进行切分（一般是按照32位或者64位），然后如果对全0或者全1的数据块进行编码，将后续的全0或者全1的数据块都一起压缩到一个32的数据块中。如果是有0也有1的数据则不做压缩，但因为压缩完是32位，那数据库实际只有31位。

**示例：**

假设我们有如下位图数据（32位）：

```scss
00000000000000000000000000000000
00000000000000000000000000000000
11111111111111111111111111111111
11111111111111111111111111111111
00000000000000000000000000000000
11001100110011001100110011001100
```

#### 分块处理

将位图数据划分为字块（假设每个字块31位）：

```scss
0000000000000000000000000000000 (31位)
0000000000000000000000000000000 (31位)
1111111111111111111111111111111 (31位)
1111111111111111111111111111111 (31位)
0000000000000000000000000000000 (31位)
1100110011001100110011001100110 (31位)
```

**编码块：**

1. 全0字块（前两块）：
- 编码为填充字：`1`（最高位，表示填充字） + `0`（表示全0） + `01`（连续2个全0块）
- 填充字：`10000000000000000000000000000010`
2. 全1字块（接下来的两块）：
- 编码为填充字：`1`（最高位，表示填充字） + `1`（表示全1） + `01`（连续2个全1块）
- 填充字：`11000000000000000000000000000010`
3. 混合字块：
- 保持原样，并在最高位加`0`表示这是一个数据字块。
- `0000000000000000000000000000000` → `0000000000000000000000000000000`
- `1100110011001100110011001100110` → `01100110011001100110011001100110`

压缩后的数据为：

```scss
10000000000000000000000000000010 (填充字，全0，连续2块)
11000000000000000000000000000010 (填充字，全1，连续2块)
0000000000000000000000000000000  (数据字块)
01100110011001100110011001100110 (数据字块)
```

**注意：上面数据块中，数据块`11001100110011001100110011001100` 在分块中处理成了`1100110011001100110011001100110 (31位)`少了一个0，是因为wah是动态划分的，没有展示全；WAH 算法会将这些情况编码为填充字，而且填充字的长度可以根据需要动态调整。但基本的逻辑就是这样。**



