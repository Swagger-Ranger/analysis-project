
[toc]

### ThreadLocal的设计结构

`ThreadLocal`只是一个中间引用对象，实际的数据存储在`ThreadLocalMap`中，具体来说是存储在`ThreadLocalMap`中的`Entry`数组中。而每个线程都维护了一个`ThreadLocalMap`实例变量，

```java
    // Thread中维护了 ThreadLocal.ThreadLocalMap变量
    /*
     * ThreadLocal values pertaining to this thread. This map is maintained
     * by the ThreadLocal class.
     */
    ThreadLocal.ThreadLocalMap threadLocals;

    /*
     * InheritableThreadLocal values pertaining to this thread. This map is
     * maintained by the InheritableThreadLocal class.
     */
    ThreadLocal.ThreadLocalMap inheritableThreadLocals;
```

当向线程中添加`ThreadLocal`对象时，实际上就是在想线程的`ThreadLocal.ThreadLocalMap`变量维护的`Entry`数组中添加元素，每个元素都是一个WeakReference元素，`ThreadLocal`对象作为`WeakReference`引用的key，实际的值也就是线程中要存储的`ThreadLocal`值存储`Entry`对象的`value`对象变量中。

```java
static class Entry extends WeakReference<ThreadLocal<?>> {
            /** The value associated with this ThreadLocal. */
            Object value;

            Entry(ThreadLocal<?> k, Object v) {
                super(k);
                value = v;
            }
        }
```



而为什么采用这样的结构？Doug Lea在ThreadLocal类一开头的源码中，就这样描述ThreadLocal的目的

```text
This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e. g., a user ID or Transaction ID).
For example, the class below generates unique identifiers local to each thread. A thread's id is assigned the first time it invokes ThreadId. get() and remains unchanged on subsequent calls.
  
这个类提供了线程局部变量。这些变量的不同之处在于，每个线程(通过get或set方法)访问一个变量时，都会有一个独立初始化的变量副本。ThreadLocal实例通常是类中的私有静态字段，用于将状态与线程关联(例如，用户ID或事务ID)。 

例如，下面的类生成每个线程本地的唯一标识符。线程的id在它第一次调用threaddid时被分配。Get()，并且在后续调用中保持不变。
```

这样`ThreadLocal`对象是要保存可能存在于整个jvm中的各自目的的变量引用，然后可能在每个线程中来使用。

**并且这里面的所有复杂操作都是不用考虑并发安全的，因为数据全部都在存储在同一个线程中，不会存在多个线程的竞态条件。**



### ThreadLocal的hash码

每个`ThreadLocal`实例是通过代码：`int h = key.threadLocalHashCode & (len - 1);`获取对应的数组位置的，翻译一下就是：

> `keyIndex = ((当前threadLocal的nextHashCode值 + 1) * 0x61c88647魔数码) & (length - 1)`，`length`就是每个Thread线程中维护的ThreadLocalMap变量中维护的`Entry`数组的数组长度，并且length必定是2的n次幂，则length - 1在二进制上有效位就全是1。

因为 `nextHashCode`是静态的，进而在 JVM 中这个变量是全局唯一的，所以当每个 `ThreadLocal` 对象在创建时能通过 `nextHashCode()` 方法获取一个唯一的哈希码，进而不同的 `ThreadLocal` 对象的 `threadLocalHashCode` 是不同的，确保了它们在 `ThreadLocalMap` 中的独特性。

```java
// 在示例化threadLocal对象是会初始化threadLocalHashCode
private final int threadLocalHashCode = nextHashCode();

// ThreadLocal类的魔数码
private static final int HASH_INCREMENT = 0x61c88647;

// nextHashCode是静态的，因而与AtomicInteger类加载对象是对应的，也就是全局唯一的
private static AtomicInteger nextHashCode =
        new AtomicInteger();

// 此处 nextHashCode.getAndAdd(HASH_INCREMENT)，nextHashCode是唯一的，获取ThreadLocal示例对象对应的模数码
private static int nextHashCode() {
        return nextHashCode.getAndAdd(HASH_INCREMENT);
    }

int h = key.threadLocalHashCode & (len - 1);
```

**注意这里要保存的变量必然是处于jvm全局中的，因为其是要保存在整个jvm中各自目的的变量引用，然后可能在各个线程中来使用**。



**上面那样计算hash码的本质就是在使用全局唯一的一个变量来保证每个`ThreadLocal`实例在jvm中的数字都不相同，然后加入此魔数码作为扰动，来保证在每个`ThreadLocal`对象的哈希值对应在整个jvm中都是唯一的，而且是在16、32、64等这些2的n幂次中取模都有良好的分布的。**



#### 为什么使用0x61c88647作为魔数

```java
    /**
     * The difference between successively generated hash codes - turns
     * implicit sequential thread-local IDs into near-optimally spread
     * multiplicative hash values for power-of-two-sized tables.
     * 连续生成的哈希码之间的差异 —— 将隐式的顺序线程局部id转换为对于两个大小的表的幂的近似最优的扩展乘法哈希值。
     */
    private static final int HASH_INCREMENT = 0x61c88647;
```

`ThreadLocal`中的哈希魔数就是`1640531527`(十六进制为`0x61c88647`)。这个魔数是斐波那契数列`F(n) = F(n-1) + F(n-2)`，函数的解。

这个问题的本质就是在问：

> 为什么斐波那契数列的解乘以带符号位的32位int，获取的数值在2的n次幂长度数组中取模会有更好的分布？
>
> 附：chatgpt的回答好坏，很大程度上取决于问题的好坏，当我问：为什么使用0x61c88647魔数在ThreadLocal能减少哈希冲突，有更好的散列？，这个问题的回答深度远远不如上面问题的回答深度。

原因在于在哈希函数设计中，通常使用乘法散列法 (Multiplicative Hashing) 来获得较好的散列分布。具体的做法是选择一个合适的常数 A(即魔数)，使得对哈希表的大小取模后，输入值能够均匀分布。这种方法的基本思路来源于「乘法哈希」的概念。而这个常数就是黄金分割点即斐波那契数列的解。

**即本质就是一个扰动函数来改善在2的n次幂中取模的分布，使其分布更加均匀。而为什么斐波那契数列解作为扰动函数，有这样的特性呢？原因在于其函数`F(n)=F(n−1)+F(n−2)`，这种递归定义使得其元素具有较高的随机性和非线性增长特性。**为什么斐波那契数列会有如此的分布，那就是个数学问题了，给一个关于极坐标(lgn,lgn-rad)下斐波那契数的分布图，感受一下：

<div style={{ textAlign: 'center', width: '100%' }}>
  <img src="/analysis-project/img/juc/juc-29.png" alt="image" style={{ maxWidth: '36%', height: 'auto', display: 'block', margin: '0 auto' }} />
</div>

Here is an inline formula: $E=mc^2$.

$$
F(n) \approx \frac{\phi^n}{\sqrt{5}}
$$
